#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Oct 12 19:48:49 2020

@author: duypham

Inspired by and inherited from Matlab version of GSA code v1.1.(Generated by Esmat Rashedi, 2010. "E. Rashedi, H. Nezamabadi-pour and S. Saryazdi, GSA: A Gravitational Search Algorithm, Information sciences, vol. 179, no. 13, pp. 2232-2248, 2009."
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math

def GSA_initialization(dim,N,up,down):
  if np.shape(up)[0]==1 or np.shape(up)[0]==None:
    X = np.random.rand(N,dim)*(up-down)+down

  if np.shape(up)[0]>1:
    X = np.zeros((int(N),np.shape(up)[0]))
    for i in range(dim):
      high = up[i]
      low = down[i]
      X[:,i] = (np.random.rand(int(N),1)*(high-low)+low).reshape(-1)
  return X

def GSA_top_functions(P,num_relay,CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                           discrimination_time, min_TDS, max_TDS, min_TMS):
  # P = [TDS, C1, C2, C3]
  # You can insert your own objective function with a new Benchmark_Function_ID.
  step_TOP = 0.001;
  n = (discrimination_time/step_TOP)*2
  TDS = P[0]
  C1 = P[1]
  C2 = P[2]
  C3 = P[3]
  step_TDS = 0.01

  n_TDS = np.random.randn(int(n),1)*max_TDS-min_TDS+min_TDS

  fittemp = np.zeros((int(n),1))
  for i in range(int(n)):
    # TOP_Desired_For_Present_Relay=TOP_Desired+Discrimination_Time;
    M = Ifault/Ipick
    K = C1/((M**C2)-1)+C3
    OperatingTimeTemp = K*n_TDS[i]
    if (num_relay==1):
      TOP_min = TOP_desired
    else:
      TOP_min = TOP_desired + min_TMS
    
    if (TOP_min<=OperatingTimeTemp):
      fittemp[i] = OperatingTimeTemp
    else:
      fittemp[i] = 1000
  fit = fittemp.min()
  index = fittemp.argmin()
  OperatingTime = fit
  C0 = n_TDS[index][0]
  position = np.array([C0,C1, C2, C3])

  return position, OperatingTime

def GSA_evaluateF(X,num_relay,CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                            discrimination_time, min_TDS, max_TDS, min_TMS):
  N,dim = X.shape
  X_new = []
  fitness = np.zeros((N,1))
  for i in range(N):
    # L is the location of agent number 'i'
    L = X[i,:]
    # calculation of objective function for agent number 'i'
    position, fitness[i] = GSA_top_functions(L,num_relay,CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                            discrimination_time, min_TDS, max_TDS, min_TMS);
    X_new.append(position)
  return np.array(X_new), fitness

def GSA_move(X,a,V):
  # movement.
  N,dim = X.shape
  V = np.random.rand(N,dim)*V + a # eq. 11.
  X = X + V # eq. 12.
  return X,V

def GSA_Gfield(M,X,G,R_norm,R_power,elitist_check,iteration,max_iter):
  N,dim = X.shape;
  final_percent = 2 # In the last iteration, only 2 percent of agents apply force to the others.

# total force calculation
  if elitist_check==1:
    kbest = final_percent + (1-iteration/max_iter)*(100-final_percent); # kbest in eq. 21.
    kbest = int(np.round(N*kbest/100));
  else:
     kbest=N # eq.9.
  Ms = M.sort(axis=1)
  ds = M.argsort(axis=1)[::-1]
  E = np.zeros((N,dim))
  for i in range(N):
    for ii in range(kbest):
      j=ds[ii]
      if j!=i:
        R = np.linalg.norm((X[i]-X[j])[0],ord=R_norm) # Euclidian distanse.
        for k in range(dim):
          E[i,k] = E[i,k]+np.random.random()*(M[j])*((X[j,k]-X[i,k])/(R**R_power+np.finfo(float).eps))

  # acceleration
  a=E*G  # note that Mp(i)/Mi(i)=1
  return a

def GSA_Gconstant(iteration,max_iter):
  # here, make your own function of 'G'
  alpha = 20
  G_0 = 100
  G = G_0*np.exp(-alpha*iteration/max_iter); #eq. 28.
  return G

def GSA_massCalculation(fit,min_flag):
  Fmax=max(fit)
  Fmin=min(fit)
  Fmean=np.mean(fit)
  i, N = fit.shape

  if Fmax==Fmin:
    M = np.ones((N,1));
  else:
    if min_flag==1: # for minimization
        best = Fmin
        worst = Fmax # eq.17-18.
    else: # for maximization
        best = Fmax
        worst = Fmin # %eq.19-20.
    
    M = (fit-worst) / (best-worst) # eq.15,

  M=M/sum(M) # eq. 16.

  return M

def GSA_space_bound(X,up,low):
  N,dim = X.shape
  up = np.array(up)
  for i in range(N):
    # Agents that go out of the search space, are reinitialized randomly .
    Tp = (X[i,:] > up).any()
    Tm = (X[i,:] < low).any()
    X[i,:] = (X[i,:]*(not(Tp+Tm)))+((np.random.rand(1,dim)*(up-low)+low)*(Tp+Tm))
    # Agents that go out of the search space, are returned to the boundaries.
    #         Tp=X(i,:)>up;Tm=X(i,:)<low;X(i,:)=(X(i,:).*(~(Tp+Tm)))+up.*Tp+low.*Tm;

  return X

def GSA(N, max_iter, num_relay, CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                              discrimination_time, min_top, max_top, min_C1, max_C1, min_C2, max_C2, min_C3, max_C3, min_TDS, max_TDS,min_TMS, elitist_check,min_flag,R_power):

  #V:   Velocity.
  #a:   Acceleration.
  #M:   Mass.  Ma=Mp=Mi=M;
  #dim: Dimension of the test function.
  #N:   Number of agents.
  #X:   Position of agents. dim-by-N matrix.
  #R:   Distance between agents in search space.
  #[low-up]: Allowable range for search space.
  #R_norm:  Norm in eq.8.
  #R_power: Power of R in eq.7.
  
  R_norm = 2
  
  #get allowable range and dimension of the test function.
  #[low,up,dim]=test_functions_range(F_index);
  low = [min_TDS, min_C1, min_C2, min_C3]
  up = [max_TDS, max_C1, max_C2, max_C3]
  dim = 4

  # random initialization for agents.
  X = GSA_initialization(dim,N,up,low); 

  # create the best so far chart and average fitnesses chart.
  BestChart=[]
  MeanChart=[]

  V = np.zeros((int(N),dim));

  for iteration in range(max_iter):
    # Checking allowable range. 
    X = GSA_space_bound(X,up,low) 

    # Evaluation of agents. 
    X, fitness = GSA_evaluateF(X,num_relay,CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                            discrimination_time, max_TDS, max_TDS, min_TMS)
      
    if min_flag==1:
      best = fitness.min() # minimization.
      best_X = fitness.argmin() # minimization.
    else:
      best = fitness.max()
      best_X = fitness.argmax() # maximization.       
      
    if iteration==0:
      gBestScore = best
      gBest = X[best_X,:]
      operating_time = best
    
    if min_flag==1:
      if best < gBestScore:  # minimization.
        gBestScore=best
        gBest = X[best_X,:]
        operating_time = best

    else: 
      if best > gBestScore:  # maximization
        gBestScore = best
        gBest = X[best_X,:]
        operating_time = best
        
    BestChart.append(gBestScore)
    MeanChart.append(np.mean(fitness))

    # Calculation of M. eq.14-20
    M = GSA_massCalculation(fitness,min_flag) 

    # Calculation of Gravitational constant. eq.13.
    G = GSA_Gconstant(iteration,max_iter)

    # Calculation of accelaration in gravitational field. eq.7-10,21.
    a = GSA_Gfield(M,X,G,R_norm,R_power,elitist_check,iteration,max_iter)

    # Agent movement. eq.11-12
    X,V = GSA_move(X,a,V)

  return gBestScore,gBest,BestChart,MeanChart,operating_time

def operatingTimeFuction(Ifn,Ip,A,B,C,I50n,TDS,plotI50n):
  if (plotI50n):
    if (Ifn<=I50n):
      operatingTime = ((A/((Ifn/Ip)**B-1))+C)*TDS
    else:
      operatingTime = 0
  else:
      operatingTime = ((A/((Ifn/Ip)**B-1))+C)*TDS
  return operatingTime
