"""
Created on Sun Oct 11 15:33:28 2020

@author: duypham

Inspired by and inherited from Matlab version of PSOGSA source code v3.0, Generated by SeyedAli Mirjalili, 2011. Adopted from: S. Mirjalili, S.Z. Mohd Hashim, New Hybrid PSOGSA Algorithm for Function Optimization, in IEEE International Conference on Computer and Information Application?ICCIA 2010), China, 2010, pp.374-377.
"""
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math

def operatingTimeFuction(Ifn,Ip,A,B,C,I50n,TDS,plotI50n):
  if (plotI50n):
    if (Ifn<=I50n):
      operatingTime = ((A/((Ifn/Ip)**B-1))+C)*TDS
    else:
      operatingTime = 0
  else:
      operatingTime = ((A/((Ifn/Ip)**B-1))+C)*TDS
  return operatingTime

def PSOGSA_top_functions(P,num_relay,CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                                 discrimination_time, min_TDS, max_TDS, min_TMS):
  step_TOP = 0.001
  n = (discrimination_time/step_TOP)*2
  TDS = P[0]
  C1 = P[1]
  C2 = P[2]
  C3 = P[3]
  step_TDS = 0.01
  n_TDS = np.random.randn(int(n),1)*(max_TDS-min_TDS)+min_TDS

  fittemp = np.zeros((int(n),1))
  for i in range(int(n)):
    M=Ifault/Ipick
    K=C1/((M**C2)-1)+C3
    OperatingTimeTemp = K*n_TDS[i]
    if (num_relay==1):
        TOP_min = TOP_desired
    else:
        TOP_min = TOP_desired + min_TMS

    if (TOP_min <= OperatingTimeTemp):
        fittemp[i] = OperatingTimeTemp
    else:
        fittemp[i] = 1000

  fit = fittemp.min()
  index = fittemp.argmin()
  OperatingTime = fit
  C0 = n_TDS[index][0]
  position = np.array([C0,C1, C2, C3])
  return position, OperatingTime

def PSOGSA(n, max_iter, num_relay, CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                              discrimination_time, min_top, max_top, min_C1, max_C1, min_C2, max_C2, min_C3, max_C3, min_TDS, max_TDS,min_TMS):
  #get allowable range and dimension of the test function.
  #[low,up,dim]=test_functions_range(F_index);
  low = [min_TDS, min_C1, min_C2, min_C3]
  up = [max_TDS, max_C1, max_C2, max_C3]
  dim = 4

  best_chart = np.zeros(max_iter)

  current_fitness = np.zeros((int(n),1))
  current_position = np.zeros((int(n),dim))
  gBest = np.zeros((1,dim))
  gBestScore = math.inf

  pBestScore = np.zeros(int(n))
  for i in range(int(n)):
    pBestScore[i] = math.inf
  pBest = np.zeros((int(n),1))

  G0 = 1                                         # gravitational constant

  for i in range(dim):
    up_i = up[i]
    low_i = low[i]
    current_position[:,i]=np.random.rand(int(n))*(up_i-low_i)+low_i # initial positions in the problem's boundary

  velocity = .3*np.random.randn(int(n),dim)
  acceleration=np.zeros((int(n),dim))
  mass = np.zeros(int(n))
  force = np.zeros((int(n),dim))

  C1=0.5 #C1 in Equation (9)
  C2=1.5 #C2 in Equation (9)

  # main loop
  it = 0                   # Iterations counter
  while it < max_iter - 1:
    G=G0*np.exp(-23*it/max_iter) # Equation (4)
    it = it + 1
    force = np.zeros((int(n),dim))
    acceleration=np.zeros((int(n),dim))
    mass = np.zeros(int(n))

    for i in range(int(n)):
      fitness = 0  
      Flag4up = current_position[i] > np.array(up).T
      Flag4low = current_position[i] < np.array(low).T
      current_position[i] = current_position[i]*(~(Flag4up+Flag4low))+np.array(up).T*Flag4up+np.array(low).T*Flag4low
    
      position, fitness = PSOGSA_top_functions(current_position[i],num_relay,CT, Ipick, Ifault, TOP_desired, tolerance_dn, \
                              discrimination_time, min_TDS, max_TDS, min_TMS)
      current_position[i] = position
      current_fitness[i] = fitness    
          
      if (pBestScore[i] > fitness):
          pBestScore[i] = fitness
          pBest[i] = current_fitness[i]
      
      if (gBestScore > fitness):
          gBestScore = fitness
          gBest = current_position[i]
          operating_time = fitness

    best = current_fitness.min()
    worst = current_fitness.max()

    best_chart[it] = gBestScore

    for pp in range(int(n)):
      if current_fitness[pp] == best:
        break
    
    for i in range(int(n)):
      mass[i] = (current_fitness[i]-0.99*worst)/(best-worst)    

    for i in range(int(n)):
      mass[i] = mass[i]*5/np.sum(mass) 

    for i in range(int(n)):
      for j in range(dim):
        for k in range(int(n)):
          if current_position[k,j] != current_position[i,j]:
            # Equation (3)
            force[i,j] = force[i,j] + np.random.rand()*G*mass[k]*mass[i]*(current_position[k,j]-current_position[i,j])/abs(current_position[k,j]-current_position[i,j])

    for i in range(int(n)):
       for j in range(dim):
          if (mass[i]!=0):
            # Equation (6)
            acceleration[i,j]=force[i,j]/mass[i]

    for i in range(int(n)):
      for j in range(dim):
        # Equation(9)
          velocity[i,j] = np.random.rand()*velocity[i,j]+C1*np.random.rand()*acceleration[i,j] + C2*np.random.rand()*(gBest[j]-current_position[i,j])

                                                        
    # Equation (10) 
    current_position = current_position + velocity
  return gBestScore, gBest, best_chart, operating_time
